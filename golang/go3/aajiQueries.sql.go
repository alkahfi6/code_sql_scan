// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: aajiQueries.sql

package sqlBanca

import (
	"context"
	"database/sql"
)

const populateDataFromBancaNoAAUITMAndBancaNoAAUITM = `-- name: PopulateDataFromBancaNoAAUITMAndBancaNoAAUITM :many
select aj.NIK, aj.Nama, aj.JobTitle, aj.AAJI, aj.DateExpire, au.AAUI, au.DateExpire, aj.DateUpload, aj.NIKUpload 
from BancaNoAAJI_TM aj
left join BancaNoAAUI_TM au
on aj.NIK = au.NIK
WHERE  aj.NIK = @p1 OR @p2 IN ('D')
		and 
		(
			(aj.DateUpload  >= convert(varchar,@p3,112) 
				and aj.DateUpload < dateadd(dd,1,@p4)  )
			OR @p2 IN ('N') 
		)
UNION ALL
select au.NIK, au.Nama, au.JobTitle, aj.AAJI, aj.DateExpire, au.AAUI, au.DateExpire, au.DateUpload, au.NIKUpload 
from BancaNoAAUI_TM au
left join BancaNoAAJI_TM aj
on aj.NIK = au.NIK
where aj.NIK is null
	AND  au.NIK = @p1 OR @p2 IN ('D')
		and 
		(
			(au.DateUpload  >= convert(varchar,@p3,112) 
				and au.DateUpload < dateadd(dd,1,@p4)  )
			OR @p2 IN ('N') 
		)
`

type PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMParams struct {
	Pnnik       sql.NullInt32 `json:"pnnik"`
	Pcfilter    interface{}   `json:"pcfilter"`
	Pdstartdate string        `json:"pdstartdate"`
	Pdenddate   interface{}   `json:"pdenddate"`
}

type PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMRow struct {
	Nik          sql.NullInt32  `json:"nik"`
	Nama         sql.NullString `json:"nama"`
	Jobtitle     sql.NullString `json:"jobtitle"`
	Aaji         sql.NullString `json:"aaji"`
	Dateexpire   interface{}    `json:"dateexpire"`
	Aaui         sql.NullString `json:"aaui"`
	Dateexpire_2 interface{}    `json:"dateexpire_2"`
	Dateupload   interface{}    `json:"dateupload"`
	Nikupload    sql.NullInt32  `json:"nikupload"`
}

func (q *Queries) PopulateDataFromBancaNoAAUITMAndBancaNoAAUITM(ctx context.Context, arg PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMParams) ([]PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMRow, error) {
	rows, err := q.db.QueryContext(ctx, populateDataFromBancaNoAAUITMAndBancaNoAAUITM,
		arg.Pnnik,
		arg.Pcfilter,
		arg.Pdstartdate,
		arg.Pdenddate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMRow
	for rows.Next() {
		var i PopulateDataFromBancaNoAAUITMAndBancaNoAAUITMRow
		if err := rows.Scan(
			&i.Nik,
			&i.Nama,
			&i.Jobtitle,
			&i.Aaji,
			&i.Dateexpire,
			&i.Aaui,
			&i.Dateexpire_2,
			&i.Dateupload,
			&i.Nikupload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataFromAAJITM = `-- name: GetDataFromAAJITM :many
select aj.NIK, aj.Nama, aj.JobTitle, aj.AAJI, aj.DateExpire, 
(
    select top 1 au.AAUI from BancaNoAAUI_TM au where au.NIK = aj.NIK
	order by au.DateUpload desc
) as AAUI,
(
    select top 1 au.DateExpire from BancaNoAAUI_TM au where au.NIK = aj.NIK
	order by au.DateUpload desc
) as DateExpireAAUI, aj.DateUpload, aj.NIKUpload 
from BancaNoAAJI_TM aj order by NIK desc
`

type GetDataFromAAJITMRow struct {
	Nik            sql.NullInt32  `json:"nik"`
	Nama           sql.NullString `json:"nama"`
	Jobtitle       sql.NullString `json:"jobtitle"`
	Aaji           sql.NullString `json:"aaji"`
	Dateexpire     interface{}    `json:"dateexpire"`
	Aaui           sql.NullString `json:"aaui"`
	Dateexpireaaui interface{}    `json:"dateexpireaaui"`
	Dateupload     interface{}    `json:"dateupload"`
	Nikupload      sql.NullInt32  `json:"nikupload"`
}

func (q *Queries) GetDataFromAAJITM(ctx context.Context) ([]GetDataFromAAJITMRow, error) {
	rows, err := q.db.QueryContext(ctx, getDataFromAAJITM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataFromAAJITMRow
	for rows.Next() {
		var i GetDataFromAAJITMRow
		if err := rows.Scan(
			&i.Nik,
			&i.Nama,
			&i.Jobtitle,
			&i.Aaji,
			&i.Dateexpire,
			&i.Aaui,
			&i.Dateexpireaaui,
			&i.Dateupload,
			&i.Nikupload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataFromAAUITM = `-- name: GetDataFromAAUITM :many
select au.NIK, au.Nama, au.JobTitle,
( 
    select top 1 aj.AAJI from BancaNoAAJI_TM aj where aj.NIK = au.NIK 
	order by aj.DateUpload desc
) as AAJI, 
(
    select top 1 aj.DateExpire from BancaNoAAJI_TM aj where aj.NIK = au.NIK 
	order by aj.DateUpload desc
) as DateExpireAAJI, au.AAUI, au.DateExpire, au.DateUpload, au.NIKUpload 
from BancaNoAAUI_TM au left join BancaNoAAJI_TM aj
on aj.NIK = au.NIK
where aj.NIK is null
`

type GetDataFromAAUITMRow struct {
	Nik            sql.NullInt32  `json:"nik"`
	Nama           sql.NullString `json:"nama"`
	Jobtitle       sql.NullString `json:"jobtitle"`
	Aaji           sql.NullString `json:"aaji"`
	Dateexpireaaji interface{}    `json:"dateexpireaaji"`
	Aaui           sql.NullString `json:"aaui"`
	Dateexpire     interface{}    `json:"dateexpire"`
	Dateupload     interface{}    `json:"dateupload"`
	Nikupload      sql.NullInt32  `json:"nikupload"`
}

func (q *Queries) GetDataFromAAUITM(ctx context.Context) ([]GetDataFromAAUITMRow, error) {
	rows, err := q.db.QueryContext(ctx, getDataFromAAUITM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataFromAAUITMRow
	for rows.Next() {
		var i GetDataFromAAUITMRow
		if err := rows.Scan(
			&i.Nik,
			&i.Nama,
			&i.Jobtitle,
			&i.Aaji,
			&i.Dateexpireaaji,
			&i.Aaui,
			&i.Dateexpire,
			&i.Dateupload,
			&i.Nikupload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteBatchIdFromBancaMTranAAJIAAUITT = `-- name: DeleteBatchIdFromBancaMTranAAJIAAUITT :exec
delete from BancaMTranAAJIAAUI_TT where BatchId = @p1
`

func (q *Queries) DeleteBatchIdFromBancaMTranAAJIAAUITT(ctx context.Context, batchid int32) error {
	_, err := q.db.ExecContext(ctx, deleteBatchIdFromBancaMTranAAJIAAUITT, batchid)
	return err
}

const checkNIKIfNotRegisterOnPeopleSoftFromPSEmployeev = `-- name: CheckNIKIfNotRegisterOnPeopleSoftFromPSEmployeev :many
select EMPLID from PSEmployee_v where EMPLID = @p1
`

func (q *Queries) CheckNIKIfNotRegisterOnPeopleSoftFromPSEmployeev(ctx context.Context, emplid sql.NullString) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, checkNIKIfNotRegisterOnPeopleSoftFromPSEmployeev, emplid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var emplid sql.NullString
		if err := rows.Scan(&emplid); err != nil {
			return nil, err
		}
		items = append(items, emplid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkNIKIsRegisterFromBancaNoAAJITM = `-- name: CheckNIKIsRegisterFromBancaNoAAJITM :many
SELECT NIK from BancaNoAAUI_TM where NIK = @p1
`

func (q *Queries) CheckNIKIsRegisterFromBancaNoAAJITM(ctx context.Context, nik sql.NullInt32) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, checkNIKIsRegisterFromBancaNoAAJITM, nik)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nik sql.NullInt32
		if err := rows.Scan(&nik); err != nil {
			return nil, err
		}
		items = append(items, nik)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkTransactionIsExistByNIKANDStatusFromBancaMTranAAJIAAUITT = `-- name: CheckTransactionIsExistByNIKANDStatusFromBancaMTranAAJIAAUITT :many
select NIKSeller from BancaMTranAAJIAAUI_TT where NIKSeller = @p1 and Status = 0
`

func (q *Queries) CheckTransactionIsExistByNIKANDStatusFromBancaMTranAAJIAAUITT(ctx context.Context, nikseller sql.NullInt32) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, checkTransactionIsExistByNIKANDStatusFromBancaMTranAAJIAAUITT, nikseller)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nikseller sql.NullInt32
		if err := rows.Scan(&nikseller); err != nil {
			return nil, err
		}
		items = append(items, nikseller)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAAJIFromBancaMTranAAJIAAUITTByNIKANDStatus = `-- name: GetAAJIFromBancaMTranAAJIAAUITTByNIKANDStatus :many
select NIKSeller from BancaMTranAAJIAAUI_TT where AAJI = @p1 and NIKSeller != @p2 and Status = 0
`

type GetAAJIFromBancaMTranAAJIAAUITTByNIKANDStatusParams struct {
	Aaji      sql.NullString `json:"aaji"`
	Nikseller sql.NullInt32  `json:"nikseller"`
}

func (q *Queries) GetAAJIFromBancaMTranAAJIAAUITTByNIKANDStatus(ctx context.Context, arg GetAAJIFromBancaMTranAAJIAAUITTByNIKANDStatusParams) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, getAAJIFromBancaMTranAAJIAAUITTByNIKANDStatus, arg.Aaji, arg.Nikseller)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nikseller sql.NullInt32
		if err := rows.Scan(&nikseller); err != nil {
			return nil, err
		}
		items = append(items, nikseller)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAAUIFromBancaMTranAAJIAAUITTByNIKANDStatus = `-- name: GetAAUIFromBancaMTranAAJIAAUITTByNIKANDStatus :many
select NIKSeller from BancaMTranAAJIAAUI_TT where AAUI = @p1 and NIKSeller != @p2 and Status = 0
`

type GetAAUIFromBancaMTranAAJIAAUITTByNIKANDStatusParams struct {
	Aaui      sql.NullString `json:"aaui"`
	Nikseller sql.NullInt32  `json:"nikseller"`
}

func (q *Queries) GetAAUIFromBancaMTranAAJIAAUITTByNIKANDStatus(ctx context.Context, arg GetAAUIFromBancaMTranAAJIAAUITTByNIKANDStatusParams) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, getAAUIFromBancaMTranAAJIAAUITTByNIKANDStatus, arg.Aaui, arg.Nikseller)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nikseller sql.NullInt32
		if err := rows.Scan(&nikseller); err != nil {
			return nil, err
		}
		items = append(items, nikseller)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBancaNoAAJITMByDate = `-- name: GetBancaNoAAJITMByDate :many
select aj.NIK, aj.Nama, aj.JobTitle, aj.AAJI, aj.DateExpire, au.AAUI, au.DateExpire, aj.DateUpload, aj.NIKUpload from BancaNoAAJI_TM aj
left join BancaNoAAUI_TM au ON aj.NIK = au.NIK where aj.DateUpload >= @p1 and aj.DateUpload <= @p2
order by  aj.NIK
`

type GetBancaNoAAJITMByDateParams struct {
	Dateupload   interface{} `json:"dateupload"`
	Dateupload_2 interface{} `json:"dateupload_2"`
}

type GetBancaNoAAJITMByDateRow struct {
	Nik          sql.NullInt32  `json:"nik"`
	Nama         sql.NullString `json:"nama"`
	Jobtitle     sql.NullString `json:"jobtitle"`
	Aaji         sql.NullString `json:"aaji"`
	Dateexpire   interface{}    `json:"dateexpire"`
	Aaui         sql.NullString `json:"aaui"`
	Dateexpire_2 interface{}    `json:"dateexpire_2"`
	Dateupload   interface{}    `json:"dateupload"`
	Nikupload    sql.NullInt32  `json:"nikupload"`
}

func (q *Queries) GetBancaNoAAJITMByDate(ctx context.Context, arg GetBancaNoAAJITMByDateParams) ([]GetBancaNoAAJITMByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getBancaNoAAJITMByDate, arg.Dateupload, arg.Dateupload_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBancaNoAAJITMByDateRow
	for rows.Next() {
		var i GetBancaNoAAJITMByDateRow
		if err := rows.Scan(
			&i.Nik,
			&i.Nama,
			&i.Jobtitle,
			&i.Aaji,
			&i.Dateexpire,
			&i.Aaui,
			&i.Dateexpire_2,
			&i.Dateupload,
			&i.Nikupload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBancaNoAAJITMByNIKDate = `-- name: GetBancaNoAAJITMByNIKDate :many
select aj.NIK, aj.Nama, aj.JobTitle, aj.AAJI, aj.DateExpire, au.AAUI, au.DateExpire, aj.DateUpload, aj.NIKUpload from BancaNoAAJI_TM aj
left join BancaNoAAUI_TM au ON aj.NIK = au.NIK where aj.DateUpload >= @p1 and aj.DateUpload <= @p2 and aj.NIK = @p3
order by aj.NIK
`

type GetBancaNoAAJITMByNIKDateParams struct {
	Dateupload   interface{}   `json:"dateupload"`
	Dateupload_2 interface{}   `json:"dateupload_2"`
	Nik          sql.NullInt32 `json:"nik"`
}

type GetBancaNoAAJITMByNIKDateRow struct {
	Nik          sql.NullInt32  `json:"nik"`
	Nama         sql.NullString `json:"nama"`
	Jobtitle     sql.NullString `json:"jobtitle"`
	Aaji         sql.NullString `json:"aaji"`
	Dateexpire   interface{}    `json:"dateexpire"`
	Aaui         sql.NullString `json:"aaui"`
	Dateexpire_2 interface{}    `json:"dateexpire_2"`
	Dateupload   interface{}    `json:"dateupload"`
	Nikupload    sql.NullInt32  `json:"nikupload"`
}

func (q *Queries) GetBancaNoAAJITMByNIKDate(ctx context.Context, arg GetBancaNoAAJITMByNIKDateParams) ([]GetBancaNoAAJITMByNIKDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getBancaNoAAJITMByNIKDate, arg.Dateupload, arg.Dateupload_2, arg.Nik)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBancaNoAAJITMByNIKDateRow
	for rows.Next() {
		var i GetBancaNoAAJITMByNIKDateRow
		if err := rows.Scan(
			&i.Nik,
			&i.Nama,
			&i.Jobtitle,
			&i.Aaji,
			&i.Dateexpire,
			&i.Aaui,
			&i.Dateexpire_2,
			&i.Dateupload,
			&i.Nikupload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastInsertedBatchId = `-- name: GetLastInsertedBatchId :one
SELECT cast(max(BatchId) as int) as BatchId FROM BancaMTranAAJIAAUI_TT
`

func (q *Queries) GetLastInsertedBatchId(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLastInsertedBatchId)
	var batchid int32
	err := row.Scan(&batchid)
	return batchid, err
}

const getNIKFromBancaNoAAJITMByAAUIANDNIK = `-- name: GetNIKFromBancaNoAAJITMByAAUIANDNIK :many
select au.NIK from BancaNoAAUI_TM au where au.AAUI = @p1 and au.NIK != @p2
`

type GetNIKFromBancaNoAAJITMByAAUIANDNIKParams struct {
	Aaui sql.NullString `json:"aaui"`
	Nik  sql.NullInt32  `json:"nik"`
}

func (q *Queries) GetNIKFromBancaNoAAJITMByAAUIANDNIK(ctx context.Context, arg GetNIKFromBancaNoAAJITMByAAUIANDNIKParams) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, getNIKFromBancaNoAAJITMByAAUIANDNIK, arg.Aaui, arg.Nik)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nik sql.NullInt32
		if err := rows.Scan(&nik); err != nil {
			return nil, err
		}
		items = append(items, nik)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNIKFromBancaNoAAUITMByAAJIANDNIK = `-- name: GetNIKFromBancaNoAAUITMByAAJIANDNIK :many
select aj.NIK from BancaNoAAJI_TM aj where aj.AAJI = @p1 and aj.NIK != @p2
`

type GetNIKFromBancaNoAAUITMByAAJIANDNIKParams struct {
	Aaji sql.NullString `json:"aaji"`
	Nik  sql.NullInt32  `json:"nik"`
}

func (q *Queries) GetNIKFromBancaNoAAUITMByAAJIANDNIK(ctx context.Context, arg GetNIKFromBancaNoAAUITMByAAJIANDNIKParams) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, getNIKFromBancaNoAAUITMByAAJIANDNIK, arg.Aaji, arg.Nik)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var nik sql.NullInt32
		if err := rows.Scan(&nik); err != nil {
			return nil, err
		}
		items = append(items, nik)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNameAndJobTitleByNIK = `-- name: GetNameAndJobTitleByNIK :many
select NAME, JOBTITLE from SQL_Employee.dbo.PSEmployee_v where EMPLID = @p1 AND EMPL_RCD = 0
`

type GetNameAndJobTitleByNIKRow struct {
	Name     sql.NullString `json:"name"`
	Jobtitle sql.NullString `json:"jobtitle"`
}

func (q *Queries) GetNameAndJobTitleByNIK(ctx context.Context, emplid sql.NullString) ([]GetNameAndJobTitleByNIKRow, error) {
	rows, err := q.db.QueryContext(ctx, getNameAndJobTitleByNIK, emplid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNameAndJobTitleByNIKRow
	for rows.Next() {
		var i GetNameAndJobTitleByNIKRow
		if err := rows.Scan(&i.Name, &i.Jobtitle); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBancaMTranAAJIAAUITT = `-- name: InsertBancaMTranAAJIAAUITT :exec
insert into BancaMTranAAJIAAUI_TT (NIKSeller, InputDate, AAJI, AAJIExpireDate, AAUI, AAUIExpireDate, NIKInputer, Status, ActionType, DeletedXML)    
select @p1, @p2, @p3, @p4, @p5, @p6, @p7, 0, @p8, @p9
`

type InsertBancaMTranAAJIAAUITTParams struct {
	Nikseller      sql.NullInt32  `json:"nikseller"`
	Inputdate      interface{}    `json:"inputdate"`
	Aaji           sql.NullString `json:"aaji"`
	Aajiexpiredate interface{}    `json:"aajiexpiredate"`
	Aaui           sql.NullString `json:"aaui"`
	Aauiexpiredate interface{}    `json:"aauiexpiredate"`
	Nikinputer     sql.NullInt32  `json:"nikinputer"`
	Actiontype     sql.NullString `json:"actiontype"`
	Deletedxml     interface{}    `json:"deletedxml"`
}

func (q *Queries) InsertBancaMTranAAJIAAUITT(ctx context.Context, arg InsertBancaMTranAAJIAAUITTParams) error {
	_, err := q.db.ExecContext(ctx, insertBancaMTranAAJIAAUITT,
		arg.Nikseller,
		arg.Inputdate,
		arg.Aaji,
		arg.Aajiexpiredate,
		arg.Aaui,
		arg.Aauiexpiredate,
		arg.Nikinputer,
		arg.Actiontype,
		arg.Deletedxml,
	)
	return err
}

const updateBatchCode = `-- name: UpdateBatchCode :exec
UPDATE BancaMTranAAJIAAUI_TT
SET BatchCode = 'M' + cast (BatchId as varchar(50)) where BatchId = @p1
`

func (q *Queries) UpdateBatchCode(ctx context.Context, batchid int32) error {
	_, err := q.db.ExecContext(ctx, updateBatchCode, batchid)
	return err
}
